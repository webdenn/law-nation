generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

/// ---------- core user model ----------
model User {
  id                        String                  @id @default(cuid())
  name                      String
  email                     String                  @unique
  phone                     String?
  passwordHash              String
  isActive                  Boolean                 @default(true)
  createdAt                 DateTime                @default(now())
  updatedAt                 DateTime                @updatedAt
  version                   Int                     @default(1)
  assignedArticles          Article[]
  auditLogs                 AuditLog[]
  refreshTokens             RefreshToken[]
  roles                     UserRole[]
  changeLogs                ArticleChangeLog[]
  notifications             Notification[]
  editorHistory             ArticleEditorHistory[]  @relation("EditorHistory")
  assignedEditorHistory     ArticleEditorHistory[]  @relation("AssignedByHistory")
}

/// ---------- roles ----------
model Role {
  id          String           @id @default(cuid())
  name        String           @unique
  description String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  permissions RolePermission[]
  users       UserRole[]
}

/// ---------- permissions ----------
model Permission {
  id          String           @id @default(cuid())
  key         String           @unique
  description String?
  module      String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  roles       RolePermission[]
}

/// ---------- user <-> role ----------
model UserRole {
  userId     String
  roleId     String
  assignedAt DateTime @default(now())
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
  @@index([roleId])
}

/// ---------- role <-> permission ----------
model RolePermission {
  roleId       String
  permissionId String
  assignedAt   DateTime   @default(now())
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([permissionId])
}

/// ---------- audit logging ----------
model AuditLog {
  id         String   @id @default(cuid())
  userId     String?
  roleName   String?
  action     String
  resource   String
  resourceId String?
  payload    Json?
  createdAt  DateTime @default(now())
  user       User?    @relation(fields: [userId], references: [id])
}

model RefreshToken {
  id        String   @id @default(cuid())
  tokenHash String
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  revoked   Boolean  @default(false)
  user      User     @relation(fields: [userId], references: [id])
}

model Article {
  id                 String                  @id @default(cuid())
  authorName         String
  authorEmail        String
  authorPhone        String?
  authorOrganization String?
  secondAuthorName         String?
  secondAuthorEmail        String?
  secondAuthorPhone        String?
  secondAuthorOrganization String?
  title              String
  slug               String                  @unique
  category           String
  abstract           String
  keywords           String?
  coAuthors          String?
  remarksToEditor    String?
  originalPdfUrl     String
  currentPdfUrl      String
  status             ArticleStatus           @default(PENDING_ADMIN_REVIEW)
  assignedEditorId   String?
  editorApprovedAt   DateTime?
  submittedAt        DateTime                @default(now())
  reviewedAt         DateTime?
  approvedAt         DateTime?
  createdAt          DateTime                @default(now())
  updatedAt          DateTime                @updatedAt
  content            String?
  contentHtml        String?
  imageUrls          String[]
  thumbnailUrl       String?
  currentWordUrl     String?
  originalFileType   String                  @default("pdf")
  originalWordUrl    String?
  assignedEditor     User?                   @relation(fields: [assignedEditorId], references: [id])
  revisions          ArticleRevision[]
  changeLogs         ArticleChangeLog[]
  notifications      Notification[]
  editorHistory      ArticleEditorHistory[]

  @@index([status])
  @@index([assignedEditorId])
  @@index([authorEmail])
  @@index([secondAuthorEmail])
  @@index([slug])
}

model ArticleRevision {
  id         String   @id @default(cuid())
  articleId  String
  pdfUrl     String
  uploadedBy String?
  comments   String?
  createdAt  DateTime @default(now())
  wordUrl    String?
  article    Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@index([articleId])
}

model EmailVerification {
  id               String    @id @default(cuid())
  resourceId       String
  resourceType     String
  email            String
  token            String    @unique
  verificationCode String?
  isVerified       Boolean   @default(false)
  verifiedAt       DateTime?
  ttl              DateTime
  metadata         Json?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([token])
  @@index([verificationCode])
  @@index([email])
  @@index([ttl])
  @@index([isVerified])
}

/// ---------- Article Change Log (Diff Tracking) ----------
model ArticleChangeLog {
  id                  String   @id @default(cuid())
  articleId           String
  versionNumber       Int
  oldFileUrl          String
  newFileUrl          String
  fileType            String   // "PDF" or "WORD"
  diffData            Json     // {added: [], removed: [], modified: []}
  visualDiffUrl       String?  // Path to visual diff PDF with markup
  visualDiffStatus    String   @default("PENDING") // "PENDING", "GENERATING", "READY", "FAILED"
  editedBy            String
  editedAt            DateTime @default(now())
  status              String   @default("pending") // "pending", "approved", "published"
  comments            String?
  editorDocumentUrl   String?  // Editor's additional uploaded document
  editorDocumentType  String?  // Original type: "PDF" or "WORD"
  article             Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  editor              User     @relation(fields: [editedBy], references: [id])

  @@index([articleId])
  @@index([editedBy])
  @@index([status])
  @@index([visualDiffStatus])
}

/// ---------- Notifications ----------
model Notification {
  id         String    @id @default(cuid())
  userId     String
  articleId  String?
  type       String    // "ARTICLE_APPROVED_BY_EDITOR", "ARTICLE_PUBLISHED", etc.
  title      String
  message    String
  isRead     Boolean   @default(false)
  createdAt  DateTime  @default(now())
  readAt     DateTime?
  metadata   Json?     // Additional data like articleTitle, editorName, etc.
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  article    Article?  @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([articleId])
  @@index([isRead])
  @@index([createdAt])
}

/// ---------- Article Editor History (Audit Trail) ----------
model ArticleEditorHistory {
  id           String    @id @default(cuid())
  articleId    String
  editorId     String
  assignedAt   DateTime  @default(now())
  unassignedAt DateTime?
  assignedBy   String    // Admin ID who made the assignment
  reason       String?   // Optional reason for assignment/reassignment
  status       String    @default("active") // "active", "reassigned", "completed"
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  
  article      Article   @relation(fields: [articleId], references: [id], onDelete: Cascade)
  editor       User      @relation("EditorHistory", fields: [editorId], references: [id])
  assignedByUser User    @relation("AssignedByHistory", fields: [assignedBy], references: [id])

  @@index([articleId])
  @@index([editorId])
  @@index([assignedBy])
  @@index([status])
  @@index([assignedAt])
}

enum ArticleStatus {
  PENDING_ADMIN_REVIEW
  ASSIGNED_TO_EDITOR
  EDITOR_EDITING
  EDITOR_APPROVED
  PENDING_APPROVAL
  APPROVED
  REJECTED
  PUBLISHED
}