import { Document, Paragraph, TextRun, HeadingLevel, AlignmentType, UnderlineType, Packer } from 'docx';
import type { DiffResult } from './diff-calculator.utils.js';

interface DiffWordOptions {
  articleTitle: string;
  versionFrom: number;
  versionTo: number;
  editorName?: string;
  generatedBy: string;
}

/**
 * Generate a Word document showing the diff with tracked changes
 */
export async function generateDiffWord(
  diffData: DiffResult,
  options: DiffWordOptions
): Promise<Buffer> {
  try {
    console.log(`üìù [Word Diff] Generating Word document...`);

    // Create document sections
    const sections = [];

    // ===== HEADER SECTION =====
    sections.push(
      new Paragraph({
        text: 'Article Diff Report',
        heading: HeadingLevel.HEADING_1,
        alignment: AlignmentType.CENTER,
        spacing: { after: 200 },
      })
    );

    sections.push(
      new Paragraph({
        children: [
          new TextRun({
            text: options.articleTitle,
            bold: true,
            size: 28,
          }),
        ],
        spacing: { after: 100 },
      })
    );

    sections.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `Version ${options.versionFrom} ‚Üí Version ${options.versionTo}`,
            size: 22,
            color: '666666',
          }),
        ],
        spacing: { after: 50 },
      })
    );

    if (options.editorName) {
      sections.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `Edited by: ${options.editorName}`,
              size: 20,
              color: '666666',
            }),
          ],
          spacing: { after: 50 },
        })
      );
    }

    sections.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `Generated: ${new Date().toLocaleString()}`,
            size: 20,
            color: '666666',
          }),
        ],
        spacing: { after: 50 },
      })
    );

    sections.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `Generated by: ${options.generatedBy}`,
            size: 20,
            color: '666666',
          }),
        ],
        spacing: { after: 200 },
      })
    );

    // ===== SUMMARY SECTION =====
    sections.push(
      new Paragraph({
        text: 'Summary',
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 200, after: 100 },
      })
    );

    sections.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `‚úì ${diffData.summary.totalAdded} lines added`,
            color: '27ae60',
            bold: true,
          }),
        ],
        spacing: { after: 50 },
      })
    );

    sections.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `‚úó ${diffData.summary.totalRemoved} lines removed`,
            color: 'e74c3c',
            bold: true,
          }),
        ],
        spacing: { after: 50 },
      })
    );

    sections.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `‚ü≥ ${diffData.summary.totalModified} lines modified`,
            color: 'f39c12',
            bold: true,
          }),
        ],
        spacing: { after: 50 },
      })
    );

    sections.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `= ${diffData.summary.totalUnchanged} lines unchanged`,
            color: '95a5a6',
            bold: true,
          }),
        ],
        spacing: { after: 200 },
      })
    );

    // ===== DETAILED CHANGES SECTION =====
    sections.push(
      new Paragraph({
        text: 'Detailed Changes',
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 200, after: 100 },
      })
    );

    // Add removed lines
    if (diffData.removed.length > 0) {
      diffData.removed.forEach((line) => {
        sections.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `- Line ${line.oldLineNumber}: ${line.content}`,
                strike: true,
                color: 'c62828',
                font: 'Courier New',
              }),
            ],
            spacing: { after: 100 },
            shading: {
              fill: 'ffebee',
            },
          })
        );
      });
    }

    // Add added lines
    if (diffData.added.length > 0) {
      diffData.added.forEach((line) => {
        sections.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `+ Line ${line.newLineNumber}: ${line.content}`,
                underline: {
                  type: UnderlineType.SINGLE,
                },
                color: '2e7d32',
                font: 'Courier New',
              }),
            ],
            spacing: { after: 100 },
            shading: {
              fill: 'e8f5e9',
            },
          })
        );
      });
    }

    // Add modified lines
    if (diffData.modified.length > 0) {
      diffData.modified.forEach((line) => {
        // Show old version (strikethrough)
        sections.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `~ Line ${line.oldLineNumber}: ${line.content}`,
                strike: true,
                color: 'e65100',
                font: 'Courier New',
              }),
            ],
            spacing: { after: 50 },
            shading: {
              fill: 'fff9e6',
            },
          })
        );

        // Show new version (underlined)
        sections.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `  ‚Üí ${line.content}`,
                underline: {
                  type: UnderlineType.SINGLE,
                },
                color: 'e65100',
                font: 'Courier New',
              }),
            ],
            spacing: { after: 100 },
            shading: {
              fill: 'fff9e6',
            },
          })
        );
      });
    }

    // If no changes
    if (
      diffData.removed.length === 0 &&
      diffData.added.length === 0 &&
      diffData.modified.length === 0
    ) {
      sections.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'No changes detected between versions.',
              color: '95a5a6',
              italics: true,
            }),
          ],
          spacing: { after: 100 },
        })
      );
    }

    // ===== FOOTER SECTION =====
    sections.push(
      new Paragraph({
        text: '',
        spacing: { before: 400 },
      })
    );

    sections.push(
      new Paragraph({
        children: [
          new TextRun({
            text: 'Law Nation - Diff Report',
            size: 18,
            color: '95a5a6',
          }),
        ],
        alignment: AlignmentType.CENTER,
      })
    );

    // Create document
    const doc = new Document({
      sections: [
        {
          properties: {},
          children: sections,
        },
      ],
    });

    // Generate buffer
    const buffer = await Packer.toBuffer(doc);

    console.log(`‚úÖ [Word Diff] Generated ${buffer.length} bytes`);

    return buffer;
  } catch (error) {
    console.error('‚ùå [Word Diff] Error generating Word document:', error);
    throw new Error('Failed to generate Word diff document');
  }
}

/**
 * Generate a simple Word document with plain text diff
 */
export async function generateSimpleDiffWord(diffData: DiffResult): Promise<Buffer> {
  const sections = [];

  sections.push(
    new Paragraph({
      text: 'Diff Report',
      heading: HeadingLevel.HEADING_1,
    })
  );

  sections.push(
    new Paragraph({
      text: `Added: ${diffData.summary.totalAdded} lines`,
    })
  );

  sections.push(
    new Paragraph({
      text: `Removed: ${diffData.summary.totalRemoved} lines`,
    })
  );

  sections.push(
    new Paragraph({
      text: `Modified: ${diffData.summary.totalModified} lines`,
    })
  );

  const doc = new Document({
    sections: [
      {
        properties: {},
        children: sections,
      },
    ],
  });

  return await Packer.toBuffer(doc);
}
